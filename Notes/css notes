<link rel=”stylesheet” type=”text/css” href=“Path To stylesheet.css” />
<style type=”text/css”>@import url(Path To stylesheet.css)</style>

Selectors:

- div
- #id
- .class
- h1, h2, p {}
- input[type=button]

Pseudo Classes
- :hover, :active, :link, :visited, :checked, :disabled, 
- :first-child , :last-child, 
	p:first-child 	---> all p elements which are the first child of any element
	p i:first-child ---> in all p elements select first i element
	p:first-child i ---> select all i elements in first child p of any element
- :nth-child(n) --> can use 5n+1, even in the place of n.

Pseudo Elements
- p::after { content: "" }--> inserts some text after each p element , ::before
- p::first-letter, p::first-line
- ::selection --> Selects the portion of an element that is selected by a user


Specificity - what to choose in case of conflicting styles
- 'User agent' provides the default value for the browser.
- if same selector is used for different rules, rule which is defined last wins (property-wise).
	lets say, .info class selector is defined twice. first it changes color to red and background to yellow. second defines color to blue. Final redering will be blue color with yellow background.
-  id defeats class incase of conflictc even if defined earlier! cuz id is considered more specific. In general "More specific wins"
- Specificity points system : id = 100, class = 10, tag = 1. if tie, take the last. 
- Inline defeats embedded/external. Javascripts adds css as inline :P
- "!important" --> 'color: red !important;' will always win over inline..! Nobody beats this.	
- css rules for text related are inherited to children if not overridden. 
- So finally, order is ---> !important > inline > specificity points > inherit > user agent defaults

------------------------------------------------------------------------------------------------------------------------------

Box Model:
- everything is a box
- total width = leftmargin + leftborder + leftpadding + width + rightpadding + rightborder + rightmargin

Float:
- default width by a block element (div, h1, p) is same as their container
- bock elements also force the next element to lie below them.
- consider container has 600px width. we have three divs with 200px each. they lie one below the other. If float:left is used, they are forced to come in the same line as 200 + 200 + 200 can fit in the single line of the container. next div will go to next line.
- clear : left | right | both ; will actually clears the float defined in left | right | both.
- Containing element problem : if float is used in children, parent will loose the height and will collapse (width is retained). 
	Hence, properties like backgroundcolor will collapse to a line. 
	Solution:
	#1 : have a clear div : <div style="clear:both;"></div> at the end. Container expands itself to contain this div.
	#2 : Overflow : adding "overflow:hidden" on container will make it go on the floating elements.  

--------------------------------------------------------------------------------------------------------------

- Centering : div { width:200px; margin:auto;} - this will set the width and lets margin share the remaining width of the browser evenly on both sides. But adds horizontal scroll if broser is made to be less than 200px width.
- Add max-width for the div { max-width:200px; margin:auto; }