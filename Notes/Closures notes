Closures in js:
1) Closures have access to variables, parameters of outer functions even after outer function returns.
2) Closures store references to the outer functions variables not the value. Hence it gets updated when value changes.
3) Keep in mind that the inner function is not called if () is not used immediately. hece whenever u call the inner function which was a return value by outer, the variables which inner function uses might be edited.

----------------------------------------------------
​function celebrityIDCreator (theCelebrities) 
{
    var i;
    var uniqueID = 100;

    for (i = 0; i < theCelebrities.length; i++) 
    {
      theCelebrities[i]["id"] = function ()  
      {
        return uniqueID + i;
      }
    }
    
    return theCelebrities;
}
​
​var actionCelebs = [{name:"Stallone", id:0}, {name:"Cruise", id:0}, {name:"Willis", id:0}];
​
​var createIdForActionCelebs = celebrityIDCreator (actionCelebs);
​
​var stalloneID = createIdForActionCelebs [0];  console.log(stalloneID.id()); // 103


reason:
- when returned from outer, theCelebrities array will have
[{name:"Stallone",id:*innerfunction*},{name:"Cruise",*innerfunction*},{name:"Willis",*innerfunction*}]

- when you call id() , it calls anonymous inner function which has access to uniqueID and i (it is now 3 as the for loop has already been executed). So it does 100+3 = 103. The result is same for any number of calls made to id().

----------------------------------------------------