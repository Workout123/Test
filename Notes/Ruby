puts sayGoodnight "John-Boy"
puts sayGoodnight("John-Boy")
puts(sayGoodnight "John-Boy")
puts(sayGoodnight("John-Boy")) -are all same

Array.new creates new empty array

a = %w{ ant bee cat dog elk } - creates array as we need it


instSection = {
  'cello'     => 'string',
  'clarinet'  => 'woodwind',
  'drum'      => 'percussion',
  'oboe'      => 'woodwind',
  'trumpet'   => 'brass',
  'violin'    => 'string'
}

Hash.new(0) - empty hash with default value 0 


if count > 10
  puts "Try again"
elsif tries == 3
  puts "You lose"
else
  puts "Enter a number"
end


while weight < 100 and numPallets <= 30
  pallet = nextPallet()
  weight += pallet.weight
  numPallets += 1
end


puts "Danger, Will Robinson" if radiation > 3000

5.times {  print "*" }
3.upto(6) {|i|  print i }
('a'..'e').each {|char| print char }  ------> *****3456abcde


class Song
  def initialize(name, artist, duration)
    @name     = name
    @artist   = artist
    @duration = duration
  end
end

$ - global
@ - instance
@@ - class


aSong = Song.new("Bicylops", "Fleck", 260)
aSong.inspect dumps out the object's id and instance variables


In Ruby, classes are never closed: you can always add methods to an existing class.


class KaraokeSong < Song
  def initialize(name, artist, duration, lyrics)
    super(name, artist, duration)
    @lyrics = lyrics
  end
end           ------> KarokeSong is the subclass of Song


Ruby support single inheritence but with the advantage of multiple inheritence by Mixins
module A
   def a1
   end
   def a2
   end
end
module B
   def b1
   end
   def b2
   end
end

class Sample
include A
include B
   def s1
   end
end

samp = Sample.new
samp.a1
samp.a2
samp.b1
samp.b2
samp.s1




